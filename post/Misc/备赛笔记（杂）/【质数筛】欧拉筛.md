# 目录

[题目](https://www.notion.so/2083aed942e580d38bc5faf3873c52bd?pvs=21)

[思路](https://www.notion.so/2083aed942e58064a855cc5f77b54b61?pvs=21)

[Code](https://www.notion.so/Code-2083aed942e580e08747c68cfc188b57?pvs=21)

# 题目

提示：本题输入输出、运算数据量较大。

- 对于 C++ 语言，如果你使用 `cin` 来输入输出，建议使用 `std::ios::sync_with_stdio(0)` 来加速，同时使用 `'\\\\n'` 换行输出。
- 对于 Java 语言，使用线性筛并且优化输入输出，也可以在规定时限内通过本题，但是时限可能较紧张。
- 对于 Python 语言，语言性能差异较大，需要使用到 `numpy` 库的数组以替代列表，且使用埃氏筛法，依然可以在合适的时间和内存消耗下通过本题。

## 题目描述

如题，给定一个范围 n，有 q个询问，每次输出第 k小的素数。

## 输入格式

第一行包含两个正整数 n,q，分别表示查询的范围和查询的个数。

接下来 q 行每行一个正整数 k，表示查询第 k小的素数。

## 输出格式

输出 q 行，每行一个正整数表示答案。

## 输入输出样例 #1

### 输入 #1

```
100 5
1
2
3
4
5
```

### 输出 #1

```
2
3
5
7
11
```

## 说明/提示

【数据范围】

对于 $100\%$ 的数据，$n = 10^8$，$1 \le q \le 10^6$，保证查询的素数不大于 $n$。

# 思路

质数查找。

本题要求查找特定范围内的质数，快速查找可以用**欧拉筛**或**埃氏筛**，考虑到欧拉筛可以在一轮循环中对已有质数进行统计，因此选择了欧拉筛。

和埃氏筛相同，欧拉筛的核心在于**一个数的任意整数倍数一定是合数**，而欧拉筛减少了对于同一个合数的重复计算（如，埃氏筛中会对16筛两次：2*8和4*4），其思路如下：

- 从2开始遍历，如果当前数在合数数组中为false，就计入质数数组；
- 用当前数去乘质数数组中的每一个数，并将结果分别标记为合数；
- 特别的，如果当前数是某一个质数的倍数，就跳出乘算。

# Code

```cpp
#include<iostream>
using namespace std;

const int N=1e8+1;
const int M=1e6+5;
int n,q,d;
int pre[N]={0};
bool comp[N]={false};
int index=0;

int main(){
	std::ios::sync_with_stdio(0);
	cin>>n>>q;
	for(int i=2;i<N;i++){
		if(comp[i]==false){
			pre[index]=i;
			index++;
			}
		for(int j=0;j<index;j++){
			if(i*pre[j]>n)break;
			comp[i*pre[j]]=true;
			if(i%pre[j]==0)break;	    
		}
	}
	for(int i=1;i<=q;i++){
		cin>>d;
		cout<<pre[d-1]<<"\\n";
	}
	return 0;
}
```